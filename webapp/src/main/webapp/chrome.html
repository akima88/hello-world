Репозитории артефактов

Репозитории артефактов являются выделенными хранилищами результатов сборки, устроенными так, чтобы упростить поиск нужного артефакта (по имени, версии, типу артефакта). Они позволяют группе разработчиков пользоваться результатами работы друг друга без необходимости иметь копии исходных кодов их модулей и выполнять сборку дерева зависимостей с 0. Maven-совместимые репозитарии стали стандартом де факто публикации результатов различных открытых проектов.

Нужно заметить, что pom-файлы, содержащие модель проекта, также являются артефактами и могут хранится в репозитариях вместе со всеми (на самом деле по крайней мере урезанные их версии, содержащие только идентификацию модуля и зависимости, хранятся всегда). Таким образом репозитарий является в том числе источником информации (как миннимум достаточной для дистрибуции) о хранимых в нём модулях.

Итак, какие бонусы они нам дают:
Структурированное хранение артефактов, их каталогизация.
Повторное использование артефактов.

Утилита управления жизненным циклом

Название получилось достаточно пафосное, однако оно вполне соответствует высокой миссии и сложности предмета.

Прежде чем погрузиться в её функции, необходимо немного познакомится с теорией организации жизненного цикла модуля в Maven. Жизненным циклом называется вся совокупность операций над модулем от инициализации сборки до развёртывания. В процессе прохождения жизненного цикла выполняются определённые операции над модулем, формируются некоторые артефакты. Жизненный цикл разделён на фазы. Каждая фаза подразумевает перевод модуля в новое состояние в результате её прохождения и появление новых артефактов. Каждая предыдущая фаза подготовливает основу для последующей. Список фаз является по сути частью POM, но глобальной, общей для всех модулей. Поный список приводить бессмысленно, но для примера приведу несколько фаз (достаточно интуитивно названных, на мой взгляд :) ) в порядке их следования: compile,… test,… deploy.

В рамках каждой фазы выполняется некоторый набор целей в зависимости от модели конкретного модуля. Цель является конкретной операцией над исходными кодами и/или артефактами.

Теперь к самой утилите. Она отвечает за реализацию жизненного цикла на основании модели проекта. Состоит из двух основных компонентов:
Во-первых из совсем маленького ядра, в котором описаны (захардкожены, как говорит простой народ) базовые принципы устройства проектов, цели по умолчанию для фаз стандартных типов проектов, рабочая среда для плагинов (интерфейсы доступа к моделям, репозитариям, ФС, настройкам и т.п.).
Во-вторых из плагинов. Они собственно содержат код, выполняющий цели. Практически вся внешняя функциональность mvn реализуется ими. Именно они генерируют, компилируют, тестируют, пакуют и т.д. и т.п.

Общение с этой утилитой построено предельно просто: вы говорите до какой кондиции фазы нужно довести клиента модуль и она это делает. Вся сложность формулировки и выполнения задач по достижению цели остаётся на совести разработчиков плагинов (ну хорошо, немного остаётся на разработчика модели). Например говорим compile и нам компилируют, причём не только то, что вылезло из VCS но и генерируют необходимое например wsimport'ом и результаты тоже компилируют.
